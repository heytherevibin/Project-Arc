"""
AGE Planner - Autonomous Goal Exploration

Implements goal-directed planning for autonomous penetration testing.
Given a high-level objective (e.g., "gain domain admin"), generates
a hierarchical plan of tactical and operational goals, and selects
the optimal sequence of attack techniques based on:
  - Current attack surface knowledge
  - Available credentials and sessions
  - Technique success history
  - Risk constraints
"""

from __future__ import annotations

import uuid
from dataclasses import dataclass, field
from datetime import datetime, timezone
from typing import Any

from core.config import get_settings
from core.logging import get_logger

logger = get_logger(__name__)


@dataclass
class PlanStep:
    """A single step in an attack plan."""
    step_id: str
    description: str
    tool_name: str
    args: dict[str, Any]
    phase: str
    risk_level: str = "low"
    requires_approval: bool = False
    depends_on: list[str] = field(default_factory=list)
    expected_outcome: str = ""
    estimated_time_seconds: int = 60
    status: str = "pending"   # pending | running | completed | failed | skipped


@dataclass
class AttackPlan:
    """A complete attack plan generated by AGE."""
    plan_id: str
    objective: str
    target: str
    strategy: str                   # Description of the overall strategy
    steps: list[PlanStep] = field(default_factory=list)
    created_at: str = field(default_factory=lambda: datetime.now(timezone.utc).isoformat())
    estimated_total_time: int = 0   # seconds
    risk_assessment: str = ""


class AGEPlanner:
    """
    Autonomous Goal Exploration planner.

    Generates attack plans by:
    1. Decomposing the objective into subgoals
    2. Mapping subgoals to available tools and techniques
    3. Ordering steps by dependencies and risk level
    4. Estimating time and resource requirements
    """

    # Standard attack chains for common objectives
    OBJECTIVE_TEMPLATES: dict[str, list[dict[str, Any]]] = {
        "web_application_pentest": [
            {"phase": "recon", "tool": "subfinder", "desc": "Enumerate subdomains", "risk": "low"},
            {"phase": "recon", "tool": "httpx", "desc": "Probe live hosts", "risk": "low"},
            {"phase": "recon", "tool": "katana", "desc": "Crawl web endpoints", "risk": "low"},
            {"phase": "recon", "tool": "wappalyzer", "desc": "Fingerprint technologies", "risk": "low"},
            {"phase": "vuln_analysis", "tool": "nuclei", "desc": "Scan for known vulnerabilities", "risk": "medium"},
            {"phase": "exploitation", "tool": "sqlmap", "desc": "Test SQL injection", "risk": "high", "approval": True},
            {"phase": "exploitation", "tool": "metasploit", "desc": "Exploit critical vulns", "risk": "critical", "approval": True},
        ],
        "network_pentest": [
            {"phase": "recon", "tool": "naabu", "desc": "Port scan target range", "risk": "low"},
            {"phase": "recon", "tool": "httpx", "desc": "Identify web services", "risk": "low"},
            {"phase": "recon", "tool": "shodan", "desc": "Passive recon via Shodan", "risk": "low"},
            {"phase": "vuln_analysis", "tool": "nuclei", "desc": "Vulnerability scanning", "risk": "medium"},
            {"phase": "exploitation", "tool": "metasploit", "desc": "Exploit network services", "risk": "critical", "approval": True},
            {"phase": "post_exploitation", "tool": "impacket", "desc": "Post-exploitation", "risk": "critical", "approval": True},
        ],
        "active_directory_attack": [
            {"phase": "recon", "tool": "bloodhound", "desc": "Collect AD data", "risk": "medium", "approval": True},
            {"phase": "recon", "tool": "crackmapexec", "desc": "Enumerate SMB shares", "risk": "medium"},
            {"phase": "exploitation", "tool": "impacket", "desc": "Kerberoasting", "risk": "high", "approval": True},
            {"phase": "exploitation", "tool": "crackmapexec", "desc": "Password spray", "risk": "critical", "approval": True},
            {"phase": "post_exploitation", "tool": "impacket", "desc": "DCSync", "risk": "critical", "approval": True},
            {"phase": "lateral_movement", "tool": "crackmapexec", "desc": "Lateral movement", "risk": "critical", "approval": True},
        ],
    }

    def __init__(self) -> None:
        self._settings = get_settings()

    def generate_plan(
        self,
        objective: str,
        target: str,
        target_type: str = "web_application_pentest",
        constraints: dict[str, Any] | None = None,
        existing_state: dict[str, Any] | None = None,
    ) -> AttackPlan:
        """
        Generate an attack plan for the given objective.

        Args:
            objective: High-level mission objective
            target: Primary target (domain, IP range, etc.)
            target_type: Type of engagement (maps to templates)
            constraints: Risk/time/scope constraints
            existing_state: Current engagement state (hosts, vulns, etc.)
        """
        constraints = constraints or {}
        existing_state = existing_state or {}

        plan_id = f"plan-{uuid.uuid4().hex[:8]}"

        # Get template for the target type
        template = self.OBJECTIVE_TEMPLATES.get(
            target_type,
            self.OBJECTIVE_TEMPLATES["web_application_pentest"],
        )

        # Filter steps based on constraints
        max_risk = constraints.get("max_risk", "critical")
        risk_order = {"low": 0, "medium": 1, "high": 2, "critical": 3}
        max_risk_val = risk_order.get(max_risk, 3)

        steps: list[PlanStep] = []
        prev_step_id: str | None = None

        for i, tmpl in enumerate(template):
            risk = tmpl.get("risk", "low")
            if risk_order.get(risk, 0) > max_risk_val:
                continue

            step_id = f"step-{plan_id}-{i:02d}"
            step = PlanStep(
                step_id=step_id,
                description=tmpl["desc"],
                tool_name=tmpl["tool"],
                args={"target": target},
                phase=tmpl["phase"],
                risk_level=risk,
                requires_approval=tmpl.get("approval", False),
                depends_on=[prev_step_id] if prev_step_id else [],
                estimated_time_seconds=self._estimate_time(tmpl["tool"]),
            )
            steps.append(step)
            prev_step_id = step_id

        # Skip recon steps if we already have data
        if existing_state.get("discovered_hosts"):
            steps = [s for s in steps if s.phase != "recon" or s.tool_name not in ("subfinder", "naabu")]

        total_time = sum(s.estimated_time_seconds for s in steps)

        plan = AttackPlan(
            plan_id=plan_id,
            objective=objective,
            target=target,
            strategy=self._describe_strategy(target_type, steps),
            steps=steps,
            estimated_total_time=total_time,
            risk_assessment=self._assess_risk(steps),
        )

        logger.info(
            "Attack plan generated",
            plan_id=plan_id,
            steps=len(steps),
            estimated_minutes=total_time // 60,
        )
        return plan

    @staticmethod
    def _estimate_time(tool: str) -> int:
        """Estimate execution time for a tool (seconds)."""
        estimates = {
            "subfinder": 60, "httpx": 120, "naabu": 180,
            "katana": 300, "nuclei": 600, "wappalyzer": 30,
            "shodan": 15, "sqlmap": 900, "metasploit": 300,
            "bloodhound": 600, "crackmapexec": 120, "impacket": 180,
        }
        return estimates.get(tool, 120)

    @staticmethod
    def _describe_strategy(target_type: str, steps: list[PlanStep]) -> str:
        """Generate a human-readable strategy description."""
        phases = list(dict.fromkeys(s.phase for s in steps))
        tools = [s.tool_name for s in steps]
        return (
            f"Execute {target_type.replace('_', ' ')} engagement through phases: "
            f"{', '.join(phases)}. Using tools: {', '.join(tools)}."
        )

    @staticmethod
    def _assess_risk(steps: list[PlanStep]) -> str:
        """Generate a risk assessment summary."""
        risk_counts = {"low": 0, "medium": 0, "high": 0, "critical": 0}
        for s in steps:
            risk_counts[s.risk_level] = risk_counts.get(s.risk_level, 0) + 1
        approval_count = sum(1 for s in steps if s.requires_approval)
        return (
            f"Risk profile: {risk_counts}. "
            f"{approval_count} steps require human approval."
        )
