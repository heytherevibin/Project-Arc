"""
Exploitability Analyser

Assesses the practical exploitability of vulnerabilities by combining
EPSS probability, public-exploit availability, environmental factors,
and weapon maturity.
"""

from __future__ import annotations

from dataclasses import dataclass
from enum import Enum
from typing import Any

from core.logging import get_logger

logger = get_logger(__name__)


class ExploitMaturity(str, Enum):
    """Weapon / exploit maturity levels (aligned with CVSS v3.1 E metric)."""
    WEAPONISED = "weaponised"       # Reliable, automated exploit exists
    FUNCTIONAL = "functional"       # PoC is reliable in most environments
    POC = "poc"                     # Proof-of-concept exists
    UNPROVEN = "unproven"           # No known exploit code
    NOT_DEFINED = "not_defined"


@dataclass
class ExploitabilityAssessment:
    """Output of exploitability analysis for a single vulnerability."""
    vuln_id: str
    cve_id: str | None
    exploitability_score: float   # 0.0 – 1.0
    maturity: ExploitMaturity
    epss_probability: float       # 0.0 – 1.0
    has_public_exploit: bool
    is_network_exploitable: bool
    requires_auth: bool
    requires_interaction: bool
    complexity: str               # "low" | "high"
    recommendation: str


class ExploitabilityAnalyser:
    """
    Calculates a normalised exploitability score for each vulnerability.

    Formula:
        score = (
            epss_weight       * epss            +
            maturity_weight   * maturity_factor  +
            access_weight     * access_factor    +
            complexity_weight * complexity_factor
        )

    All weights sum to 1.0 for a normalised [0, 1] result.
    """

    WEIGHTS = {
        "epss": 0.35,
        "maturity": 0.25,
        "access": 0.25,
        "complexity": 0.15,
    }

    MATURITY_SCORES: dict[ExploitMaturity, float] = {
        ExploitMaturity.WEAPONISED: 1.0,
        ExploitMaturity.FUNCTIONAL: 0.8,
        ExploitMaturity.POC: 0.5,
        ExploitMaturity.UNPROVEN: 0.15,
        ExploitMaturity.NOT_DEFINED: 0.3,
    }

    def assess(
        self,
        vuln: dict[str, Any],
        epss_probability: float = 0.0,
    ) -> ExploitabilityAssessment:
        """Assess exploitability of a single vulnerability."""
        cve_id = vuln.get("cve_id")
        vuln_id = vuln.get("id") or vuln.get("vulnerability_id") or cve_id or "unknown"

        # --- Determine maturity -----------------------------------------------
        maturity = self._determine_maturity(vuln)
        maturity_factor = self.MATURITY_SCORES.get(maturity, 0.3)

        # --- Access vector / attack complexity --------------------------------
        has_public_exploit = bool(vuln.get("has_public_exploit") or vuln.get("exploit_available"))
        is_network = vuln.get("attack_vector", "").upper() in ("NETWORK", "N", "")
        requires_auth = vuln.get("authentication_required", False)
        requires_interaction = vuln.get("user_interaction_required", False)
        complexity = vuln.get("attack_complexity", "low").lower()

        # Access factor: network + no-auth + no-interaction = most exploitable
        access_factor = 0.5
        if is_network:
            access_factor += 0.2
        if not requires_auth:
            access_factor += 0.15
        if not requires_interaction:
            access_factor += 0.15
        access_factor = min(1.0, access_factor)

        # Complexity factor (inverted – lower complexity → higher exploitability)
        complexity_factor = 0.9 if complexity == "low" else 0.4

        # --- Composite --------------------------------------------------------
        score = (
            self.WEIGHTS["epss"] * min(1.0, epss_probability) +
            self.WEIGHTS["maturity"] * maturity_factor +
            self.WEIGHTS["access"] * access_factor +
            self.WEIGHTS["complexity"] * complexity_factor
        )
        score = round(min(1.0, max(0.0, score)), 4)

        recommendation = self._recommend(score, maturity, has_public_exploit)

        assessment = ExploitabilityAssessment(
            vuln_id=vuln_id,
            cve_id=cve_id,
            exploitability_score=score,
            maturity=maturity,
            epss_probability=epss_probability,
            has_public_exploit=has_public_exploit,
            is_network_exploitable=is_network,
            requires_auth=requires_auth,
            requires_interaction=requires_interaction,
            complexity=complexity,
            recommendation=recommendation,
        )
        logger.debug("Exploitability assessed", vuln=vuln_id, score=score, maturity=maturity.value)
        return assessment

    def assess_batch(
        self,
        vulns: list[dict[str, Any]],
        epss_scores: dict[str, float],
    ) -> list[ExploitabilityAssessment]:
        """Assess a batch of vulnerabilities, returning sorted by exploitability."""
        results: list[ExploitabilityAssessment] = []
        for vuln in vulns:
            cve = vuln.get("cve_id", "")
            epss = epss_scores.get(cve, 0.0) if cve else 0.0
            results.append(self.assess(vuln, epss))
        results.sort(key=lambda a: a.exploitability_score, reverse=True)
        return results

    # ------------- helpers ---------------------------------------------------
    @staticmethod
    def _determine_maturity(vuln: dict[str, Any]) -> ExploitMaturity:
        """Determine exploit maturity from available metadata."""
        if vuln.get("exploit_maturity"):
            raw = vuln["exploit_maturity"].lower().replace("-", "_")
            try:
                return ExploitMaturity(raw)
            except ValueError:
                pass

        if vuln.get("metasploit_module") or vuln.get("has_metasploit"):
            return ExploitMaturity.WEAPONISED
        if vuln.get("has_public_exploit") or vuln.get("exploit_available"):
            return ExploitMaturity.FUNCTIONAL
        if vuln.get("has_poc"):
            return ExploitMaturity.POC
        return ExploitMaturity.NOT_DEFINED

    @staticmethod
    def _recommend(score: float, maturity: ExploitMaturity, has_public: bool) -> str:
        if score >= 0.8:
            return "CRITICAL: Actively exploitable — prioritise immediate remediation or exploit"
        if score >= 0.6:
            return "HIGH: Reliable exploit path likely — schedule urgent remediation or exploit"
        if score >= 0.4:
            return "MEDIUM: Exploitable under certain conditions — investigate further"
        if score >= 0.2:
            return "LOW: Limited exploitability — monitor for changes"
        return "INFO: Minimal practical exploitability"
