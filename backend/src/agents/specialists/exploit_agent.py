"""
Exploitation Specialist Agent

Handles vulnerability exploitation using Metasploit, SQLMap, and other
exploitation frameworks. All actions require human approval.
"""

from __future__ import annotations

from typing import Any

from agents.shared.base_agent import BaseAgent, Phase, ToolCall, ToolResponse
from core.logging import get_logger

logger = get_logger(__name__)


class ExploitSpecialist(BaseAgent):
    """Specialist agent for exploitation operations."""

    agent_id = "exploit"
    agent_name = "Exploitation Specialist"
    supported_phases = [Phase.EXPLOITATION]
    available_tools = ["metasploit", "sqlmap", "commix"]

    async def plan(self, state: dict[str, Any]) -> list[ToolCall]:
        """Plan exploitation actions based on discovered vulnerabilities."""
        vulns = state.get("discovered_vulns", [])
        calls: list[ToolCall] = []

        if not vulns:
            return calls

        # Sort vulnerabilities by severity (critical first)
        severity_order = {"critical": 0, "high": 1, "medium": 2, "low": 3}
        sorted_vulns = sorted(
            vulns,
            key=lambda v: severity_order.get(v.get("severity", "low"), 3),
        )

        # Attempt exploitation of top vulnerabilities
        for vuln in sorted_vulns[:5]:
            tool_name = self._select_exploit_tool(vuln)
            if tool_name:
                calls.append(ToolCall(
                    tool_name=tool_name,
                    args={
                        "target": vuln.get("matched_at", ""),
                        "vulnerability": vuln.get("template_id", ""),
                        "cve": vuln.get("cve_id"),
                    },
                    requires_approval=True,
                    risk_level="critical",
                ))

        return calls

    async def analyze(self, state: dict[str, Any], results: list[ToolResponse]) -> dict[str, Any]:
        """Analyze exploitation results."""
        for result in results:
            if not result.success or not result.data:
                continue

            data = result.data if isinstance(result.data, dict) else {}

            # Track new sessions
            session = data.get("session")
            if session:
                sessions = state.get("active_sessions", [])
                sessions.append(session)
                state["active_sessions"] = sessions

                # Track compromised hosts
                host = data.get("host") or session.get("host")
                if host:
                    compromised = state.get("compromised_hosts", [])
                    if host not in compromised:
                        compromised.append(host)
                    state["compromised_hosts"] = compromised

        logger.info(
            "Exploit analysis complete",
            sessions=len(state.get("active_sessions", [])),
            compromised=len(state.get("compromised_hosts", [])),
        )
        return state

    @staticmethod
    def _select_exploit_tool(vuln: dict[str, Any]) -> str | None:
        """Select the appropriate exploitation tool for a vulnerability."""
        template_id = vuln.get("template_id", "").lower()
        name = vuln.get("name", "").lower()

        if "sql" in name or "sqli" in template_id:
            return "sqlmap"
        if "rce" in name or "remote-code" in template_id:
            return "metasploit"
        if "command" in name and "injection" in name:
            return "commix"

        # Default to metasploit for critical/high severity
        if vuln.get("severity") in ("critical", "high"):
            return "metasploit"

        return None
