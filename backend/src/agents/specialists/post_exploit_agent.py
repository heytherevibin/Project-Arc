"""
Post-Exploitation Specialist Agent

Handles credential harvesting, privilege escalation, persistence,
and data discovery on compromised hosts.
"""

from __future__ import annotations

from typing import Any

from agents.shared.base_agent import BaseAgent, Phase, ToolCall, ToolResponse
from core.logging import get_logger

logger = get_logger(__name__)


class PostExploitSpecialist(BaseAgent):
    """Specialist agent for post-exploitation operations."""

    agent_id = "post_exploit"
    agent_name = "Post-Exploitation Specialist"
    supported_phases = [Phase.POST_EXPLOITATION, Phase.LATERAL_MOVEMENT]
    available_tools = [
        "sliver", "impacket", "crackmapexec",
        "bloodhound", "certipy", "mimikatz",
    ]

    async def plan(self, state: dict[str, Any]) -> list[ToolCall]:
        """Plan post-exploitation actions on compromised hosts."""
        sessions = state.get("active_sessions", [])
        compromised = state.get("compromised_hosts", [])
        calls: list[ToolCall] = []

        if not sessions:
            return calls

        for session in sessions[:3]:
            session_id = session.get("session_id", "")
            host = session.get("host", "")

            # Credential harvesting
            calls.append(ToolCall(
                tool_name="credential_dump",
                args={"session_id": session_id, "host": host},
                requires_approval=True,
                risk_level="critical",
            ))

            # BloodHound collection (if AD environment)
            if session.get("is_domain_joined"):
                calls.append(ToolCall(
                    tool_name="bloodhound",
                    args={"session_id": session_id, "collection": "All"},
                    requires_approval=True,
                    risk_level="high",
                ))

            # Privilege escalation check
            if not session.get("is_admin"):
                calls.append(ToolCall(
                    tool_name="privilege_escalation",
                    args={"session_id": session_id, "host": host},
                    requires_approval=True,
                    risk_level="high",
                ))

        return calls

    async def analyze(self, state: dict[str, Any], results: list[ToolResponse]) -> dict[str, Any]:
        """Analyze post-exploitation results."""
        for result in results:
            if not result.success or not result.data:
                continue

            data = result.data if isinstance(result.data, dict) else {}

            # Track harvested credentials
            creds = data.get("credentials", [])
            if creds:
                existing = state.get("harvested_creds", [])
                existing.extend(creds)
                state["harvested_creds"] = existing

            # Track new sessions from lateral movement
            new_session = data.get("session")
            if new_session:
                sessions = state.get("active_sessions", [])
                sessions.append(new_session)
                state["active_sessions"] = sessions

        logger.info(
            "Post-exploit analysis complete",
            credentials=len(state.get("harvested_creds", [])),
            sessions=len(state.get("active_sessions", [])),
        )
        return state
