"""
Post-Exploit Sub-graph

Dedicated LangGraph StateGraph for post-exploitation operations.

Flow:  credential_harvest → privilege_escalate → persist → lateral → (end)

Chains the post-exploit, persistence, pivot, and exfil specialist agents
into an ordered workflow with conditional short-circuiting.
"""

from __future__ import annotations

from typing import Any

from langgraph.graph import END, StateGraph

from agents.shared.base_agent import Phase
from agents.supervisor.state import AgentState
from core.logging import get_logger

logger = get_logger(__name__)


# ---------------------------------------------------------------------------
# Node implementations
# ---------------------------------------------------------------------------

async def credential_harvest_node(state: AgentState) -> AgentState:
    """
    Harvest credentials from active sessions: memory dumps, config files,
    password stores, tokens.
    """
    from agents.specialists.post_exploit_agent import PostExploitSpecialist

    sessions = state.get("active_sessions", [])
    if not sessions:
        return state

    agent = PostExploitSpecialist()
    tool_calls = await agent.plan(state)

    results = []
    for tc in tool_calls:
        result = await agent.execute_tool(tc)
        results.append(result)

    state = await agent.analyze(state, results)

    creds = state.get("harvested_creds", [])
    state["messages"] = state.get("messages", []) + [{
        "role": "agent",
        "content": f"[PostExploit/Harvest] Harvested {len(creds)} credentials from {len(sessions)} sessions",
    }]

    logger.info("Credential harvesting complete", creds=len(creds))
    return state


async def privilege_escalate_node(state: AgentState) -> AgentState:
    """
    Attempt privilege escalation on compromised hosts using harvested
    credentials and local exploit techniques.
    """
    from agents.specialists.post_exploit_agent import PostExploitSpecialist
    from agents.shared.base_agent import ToolCall

    sessions = state.get("active_sessions", [])
    if not sessions:
        return state

    agent = PostExploitSpecialist()

    # Build privesc tool calls for non-admin sessions
    privesc_calls = []
    for session in sessions:
        if not session.get("is_admin", False):
            privesc_calls.append(ToolCall(
                tool_name="metasploit",
                args={
                    "module": "post/multi/recon/local_exploit_suggester",
                    "session_id": session.get("session_id", ""),
                },
                requires_approval=True,
                risk_level="high",
            ))

    results = []
    for tc in privesc_calls:
        result = await agent.execute_tool(tc)
        results.append(result)

    state = await agent.analyze(state, results)

    state["messages"] = state.get("messages", []) + [{
        "role": "agent",
        "content": f"[PostExploit/PrivEsc] Attempted privilege escalation on {len(privesc_calls)} sessions",
    }]

    logger.info("Privilege escalation complete", attempts=len(privesc_calls))
    return state


async def persist_node(state: AgentState) -> AgentState:
    """
    Establish persistence mechanisms on compromised hosts.
    """
    from agents.specialists.persistence_agent import PersistenceSpecialist

    sessions = state.get("active_sessions", [])
    if not sessions:
        return state

    agent = PersistenceSpecialist()
    tool_calls = await agent.plan(state)

    results = []
    for tc in tool_calls:
        result = await agent.execute_tool(tc)
        results.append(result)

    state = await agent.analyze(state, results)

    state["messages"] = state.get("messages", []) + [{
        "role": "agent",
        "content": f"[PostExploit/Persist] Established persistence on compromised hosts",
    }]

    logger.info("Persistence established")
    return state


async def lateral_movement_node(state: AgentState) -> AgentState:
    """
    Lateral movement: use harvested credentials and active sessions
    to pivot to new hosts.
    """
    from agents.specialists.pivot_agent import PivotSpecialist

    creds = state.get("harvested_creds", [])
    if not creds:
        return state

    agent = PivotSpecialist()
    tool_calls = await agent.plan(state)

    results = []
    for tc in tool_calls:
        result = await agent.execute_tool(tc)
        results.append(result)

    state = await agent.analyze(state, results)

    compromised = state.get("compromised_hosts", [])
    state["messages"] = state.get("messages", []) + [{
        "role": "agent",
        "content": f"[PostExploit/Lateral] Pivoted to {len(compromised)} total hosts",
    }]

    logger.info("Lateral movement complete", compromised_hosts=len(compromised))
    return state


async def exfiltrate_node(state: AgentState) -> AgentState:
    """
    Data exfiltration: collect and stage sensitive data from compromised
    hosts for reporting/evidence.
    """
    from agents.specialists.exfil_agent import ExfiltrationSpecialist

    sessions = state.get("active_sessions", [])
    if not sessions:
        return state

    agent = ExfiltrationSpecialist()
    tool_calls = await agent.plan(state)

    results = []
    for tc in tool_calls:
        result = await agent.execute_tool(tc)
        results.append(result)

    state = await agent.analyze(state, results)

    state["messages"] = state.get("messages", []) + [{
        "role": "agent",
        "content": "[PostExploit/Exfil] Data exfiltration evidence collection complete",
    }]

    logger.info("Exfiltration complete")
    return state


# ---------------------------------------------------------------------------
# Conditional edges
# ---------------------------------------------------------------------------

def _has_sessions(state: AgentState) -> str:
    if state.get("active_sessions"):
        return "privilege_escalate"
    return "__end__"


def _should_persist(state: AgentState) -> str:
    # Persist if we have admin sessions
    sessions = state.get("active_sessions", [])
    if any(s.get("is_admin") for s in sessions):
        return "persist"
    # Skip persistence — go straight to lateral if we have creds
    if state.get("harvested_creds"):
        return "lateral"
    return "__end__"


def _should_move_lateral(state: AgentState) -> str:
    if state.get("harvested_creds"):
        return "lateral"
    return "__end__"


def _should_exfil(state: AgentState) -> str:
    """Exfiltrate if we compromised multiple hosts."""
    compromised = state.get("compromised_hosts", [])
    if len(compromised) >= 2:
        return "exfiltrate"
    return "__end__"


# ---------------------------------------------------------------------------
# Builder
# ---------------------------------------------------------------------------

def build_post_exploit_subgraph() -> StateGraph:
    """
    Build the post-exploitation sub-graph.

    Chains credential harvesting → privilege escalation → persistence
    → lateral movement → exfiltration, with conditional short-circuits
    at each stage.
    """
    graph = StateGraph(AgentState)

    graph.add_node("credential_harvest", credential_harvest_node)
    graph.add_node("privilege_escalate", privilege_escalate_node)
    graph.add_node("persist", persist_node)
    graph.add_node("lateral", lateral_movement_node)
    graph.add_node("exfiltrate", exfiltrate_node)

    graph.set_entry_point("credential_harvest")

    graph.add_conditional_edges(
        "credential_harvest",
        _has_sessions,
        {"privilege_escalate": "privilege_escalate", "__end__": END},
    )
    graph.add_conditional_edges(
        "privilege_escalate",
        _should_persist,
        {"persist": "persist", "lateral": "lateral", "__end__": END},
    )
    graph.add_conditional_edges(
        "persist",
        _should_move_lateral,
        {"lateral": "lateral", "__end__": END},
    )
    graph.add_conditional_edges(
        "lateral",
        _should_exfil,
        {"exfiltrate": "exfiltrate", "__end__": END},
    )
    graph.add_edge("exfiltrate", END)

    return graph
