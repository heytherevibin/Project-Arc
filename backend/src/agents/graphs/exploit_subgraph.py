"""
Exploit Sub-graph

Dedicated LangGraph StateGraph for the exploitation phase.

Flow:  vuln_prioritize → select_exploit → approval_gate → execute → verify → (end)

Includes a human-in-the-loop approval gate before any exploit
execution to ensure safety and authorisation.
"""

from __future__ import annotations

from typing import Any

from langgraph.graph import END, StateGraph

from agents.shared.base_agent import Phase
from agents.supervisor.state import AgentState
from core.logging import get_logger

logger = get_logger(__name__)


# ---------------------------------------------------------------------------
# Node implementations
# ---------------------------------------------------------------------------

async def vuln_prioritize_node(state: AgentState) -> AgentState:
    """
    Prioritise discovered vulnerabilities by exploitability,
    severity, and strategic value.
    """
    vulns = state.get("discovered_vulns", [])
    if not vulns:
        state["_exploit_targets"] = []
        return state

    severity_order = {"critical": 0, "high": 1, "medium": 2, "low": 3, "info": 4}
    sorted_vulns = sorted(
        vulns,
        key=lambda v: severity_order.get(v.get("severity", "low"), 3),
    )

    # Take top exploitable vulns
    targets = sorted_vulns[:10]
    state["_exploit_targets"] = targets

    state["messages"] = state.get("messages", []) + [{
        "role": "agent",
        "content": f"[Exploit/Prioritize] Selected {len(targets)} vulnerabilities for exploitation attempt",
    }]

    logger.info("Vulns prioritised", count=len(targets))
    return state


async def select_exploit_node(state: AgentState) -> AgentState:
    """
    Select the appropriate exploit tool and technique for each
    target vulnerability.
    """
    from agents.specialists.exploit_agent import ExploitSpecialist

    targets = state.get("_exploit_targets", [])
    if not targets:
        return state

    agent = ExploitSpecialist()
    tool_calls = await agent.plan(state)

    state["_planned_exploits"] = [
        {"tool": tc.tool_name, "args": tc.args, "risk": tc.risk_level}
        for tc in tool_calls
    ]

    state["messages"] = state.get("messages", []) + [{
        "role": "agent",
        "content": f"[Exploit/Select] Prepared {len(tool_calls)} exploit payloads awaiting approval",
    }]

    logger.info("Exploits selected", count=len(tool_calls))
    return state


async def approval_gate_node(state: AgentState) -> AgentState:
    """
    Human-in-the-loop gate.  The graph will be interrupted here;
    external code must approve before resuming.
    """
    planned = state.get("_planned_exploits", [])
    if not planned:
        return state

    state["pending_approvals"] = state.get("pending_approvals", []) + [{
        "type": "exploit_execution",
        "description": f"Execute {len(planned)} exploits against target",
        "details": planned,
        "status": "pending",
    }]

    logger.info("Exploit approval requested", exploit_count=len(planned))
    return state


async def execute_node(state: AgentState) -> AgentState:
    """
    Execute approved exploits sequentially and collect results.
    """
    from agents.specialists.exploit_agent import ExploitSpecialist
    from agents.shared.base_agent import ToolCall

    planned = state.get("_planned_exploits", [])
    if not planned:
        return state

    agent = ExploitSpecialist()
    results = []

    for exploit in planned:
        tc = ToolCall(
            tool_name=exploit["tool"],
            args=exploit["args"],
            requires_approval=False,  # already approved
            risk_level=exploit.get("risk", "high"),
        )
        result = await agent.execute_tool(tc)
        results.append(result)

        # Record in execution log
        tool_log = state.get("tool_execution_log", [])
        tool_log.append({
            "tool": tc.tool_name,
            "success": result.success,
            "duration_ms": result.duration_ms,
        })
        state["tool_execution_log"] = tool_log

    state = await agent.analyze(state, results)

    sessions = state.get("active_sessions", [])
    state["messages"] = state.get("messages", []) + [{
        "role": "agent",
        "content": f"[Exploit/Execute] Executed {len(planned)} exploits, {len(sessions)} active sessions",
    }]

    logger.info("Exploit execution complete", sessions=len(sessions))
    return state


async def verify_node(state: AgentState) -> AgentState:
    """
    Verify exploit success: check session stability, confirm
    access level, document evidence.
    """
    sessions = state.get("active_sessions", [])
    verified: list[dict[str, Any]] = []

    for session in sessions:
        # Simple verification: mark session as verified
        session["verified"] = True
        verified.append(session)

    state["active_sessions"] = verified
    state["messages"] = state.get("messages", []) + [{
        "role": "agent",
        "content": f"[Exploit/Verify] Verified {len(verified)} sessions",
    }]

    logger.info("Exploit verification complete", verified=len(verified))
    return state


# ---------------------------------------------------------------------------
# Conditional edges
# ---------------------------------------------------------------------------

def _has_exploit_targets(state: AgentState) -> str:
    if state.get("_exploit_targets"):
        return "select_exploit"
    return "__end__"


def _has_planned_exploits(state: AgentState) -> str:
    if state.get("_planned_exploits"):
        return "approval_gate"
    return "__end__"


def _route_after_approval(state: AgentState) -> str:
    """After approval gate, check if approved — then execute."""
    pending = [
        a for a in state.get("pending_approvals", [])
        if a.get("type") == "exploit_execution" and a.get("status") == "pending"
    ]
    if pending:
        # Still waiting — remain at approval gate (graph interrupts here)
        return "__end__"
    return "execute"


def _after_execute(state: AgentState) -> str:
    if state.get("active_sessions"):
        return "verify"
    return "__end__"


# ---------------------------------------------------------------------------
# Builder
# ---------------------------------------------------------------------------

def build_exploit_subgraph() -> StateGraph:
    """
    Build the exploit sub-graph.

    The graph is designed to be interrupted at the ``approval_gate``
    node.  Use ``interrupt_before=["approval_gate"]`` when compiling.
    """
    graph = StateGraph(AgentState)

    graph.add_node("vuln_prioritize", vuln_prioritize_node)
    graph.add_node("select_exploit", select_exploit_node)
    graph.add_node("approval_gate", approval_gate_node)
    graph.add_node("execute", execute_node)
    graph.add_node("verify", verify_node)

    graph.set_entry_point("vuln_prioritize")

    graph.add_conditional_edges(
        "vuln_prioritize",
        _has_exploit_targets,
        {"select_exploit": "select_exploit", "__end__": END},
    )
    graph.add_conditional_edges(
        "select_exploit",
        _has_planned_exploits,
        {"approval_gate": "approval_gate", "__end__": END},
    )
    graph.add_conditional_edges(
        "approval_gate",
        _route_after_approval,
        {"execute": "execute", "__end__": END},
    )
    graph.add_conditional_edges(
        "execute",
        _after_execute,
        {"verify": "verify", "__end__": END},
    )
    graph.add_edge("verify", END)

    return graph
