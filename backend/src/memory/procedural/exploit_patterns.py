"""
Exploit Pattern Memory

Records successful exploit chains as reusable patterns so the agent
can quickly identify the best attack approach for similar targets
in future engagements.
"""

from __future__ import annotations

import json
import uuid
from dataclasses import dataclass, field
from datetime import datetime, timezone
from typing import Any

from core.logging import get_logger
from graph.client import Neo4jClient

logger = get_logger(__name__)


@dataclass
class ExploitPattern:
    """A recorded exploit chain pattern."""
    pattern_id: str
    target_type: str          # e.g. "web_app", "network_service", "ad_domain"
    vuln_type: str            # e.g. "sqli", "rce", "ssrf"
    tools_used: list[str]     # ordered tool chain
    steps: list[dict[str, Any]]  # [{tool, args, outcome}]
    success_count: int = 0
    failure_count: int = 0
    avg_duration_ms: float = 0.0
    last_used: str = ""
    tags: list[str] = field(default_factory=list)


class ExploitPatternMemory:
    """
    Pattern memory backed by Neo4j.

    Stores :ExploitPattern nodes linked to :Technique nodes.
    Enables pattern matching: "for target type X with vuln type Y,
    which tool chain has the highest success rate?"
    """

    def __init__(self, client: Neo4jClient) -> None:
        self._client = client

    # ------------------------------------------------------------------
    # Record
    # ------------------------------------------------------------------

    async def record_pattern(
        self,
        target_type: str,
        vuln_type: str,
        tools_used: list[str],
        steps: list[dict[str, Any]],
        success: bool,
        duration_ms: float = 0.0,
        tags: list[str] | None = None,
    ) -> str:
        """
        Record (or update) an exploit pattern.

        If a pattern with matching (target_type, vuln_type, tools_used)
        already exists, increment its counters; otherwise create a new one.
        """
        tools_key = ",".join(sorted(tools_used))
        pattern_id = f"pat-{target_type}-{vuln_type}-{tools_key}"

        now = datetime.now(timezone.utc).isoformat()

        query = """
        MERGE (p:ExploitPattern {pattern_id: $pattern_id})
        ON CREATE SET
            p.target_type   = $target_type,
            p.vuln_type     = $vuln_type,
            p.tools_used    = $tools_used,
            p.steps         = $steps,
            p.success_count = CASE WHEN $success THEN 1 ELSE 0 END,
            p.failure_count = CASE WHEN $success THEN 0 ELSE 1 END,
            p.avg_duration_ms = $duration_ms,
            p.last_used     = $now,
            p.tags          = $tags
        ON MATCH SET
            p.success_count = p.success_count + CASE WHEN $success THEN 1 ELSE 0 END,
            p.failure_count = p.failure_count + CASE WHEN $success THEN 0 ELSE 1 END,
            p.avg_duration_ms = (p.avg_duration_ms + $duration_ms) / 2.0,
            p.last_used     = $now,
            p.steps         = CASE WHEN $success THEN $steps ELSE p.steps END
        RETURN p.pattern_id AS pid
        """

        params = {
            "pattern_id": pattern_id,
            "target_type": target_type,
            "vuln_type": vuln_type,
            "tools_used": tools_used,
            "steps": json.dumps(steps),
            "success": success,
            "duration_ms": duration_ms,
            "now": now,
            "tags": tags or [],
        }

        await self._client.execute_write(query, params)
        logger.debug("Exploit pattern recorded", pattern_id=pattern_id, success=success)
        return pattern_id

    # ------------------------------------------------------------------
    # Retrieval
    # ------------------------------------------------------------------

    async def find_similar_patterns(
        self,
        target_type: str | None = None,
        vuln_type: str | None = None,
        limit: int = 10,
    ) -> list[ExploitPattern]:
        """
        Find patterns matching the given criteria, ranked by success rate.
        """
        filters: list[str] = []
        params: dict[str, Any] = {"limit": limit}

        if target_type:
            filters.append("p.target_type = $target_type")
            params["target_type"] = target_type
        if vuln_type:
            filters.append("p.vuln_type = $vuln_type")
            params["vuln_type"] = vuln_type

        where = " AND ".join(filters) if filters else "TRUE"

        query = f"""
        MATCH (p:ExploitPattern)
        WHERE {where}
        WITH p, CASE WHEN (p.success_count + p.failure_count) > 0
            THEN toFloat(p.success_count) / (p.success_count + p.failure_count)
            ELSE 0.0 END AS success_rate
        RETURN p, success_rate
        ORDER BY success_rate DESC, p.last_used DESC
        LIMIT $limit
        """

        records = await self._client.execute_read(query, params)
        return [self._to_pattern(r["p"]) for r in records]

    async def get_best_pattern(
        self,
        target_type: str,
        vuln_type: str,
    ) -> ExploitPattern | None:
        """Get the single best pattern for a target+vuln combination."""
        patterns = await self.find_similar_patterns(
            target_type=target_type,
            vuln_type=vuln_type,
            limit=1,
        )
        return patterns[0] if patterns else None

    # ------------------------------------------------------------------
    # Helpers
    # ------------------------------------------------------------------

    @staticmethod
    def _to_pattern(node: Any) -> ExploitPattern:
        props = dict(node) if hasattr(node, "__iter__") else {}
        steps_raw = props.get("steps", "[]")
        if isinstance(steps_raw, str):
            try:
                steps = json.loads(steps_raw)
            except json.JSONDecodeError:
                steps = []
        else:
            steps = steps_raw

        return ExploitPattern(
            pattern_id=props.get("pattern_id", ""),
            target_type=props.get("target_type", ""),
            vuln_type=props.get("vuln_type", ""),
            tools_used=props.get("tools_used", []),
            steps=steps,
            success_count=int(props.get("success_count", 0)),
            failure_count=int(props.get("failure_count", 0)),
            avg_duration_ms=float(props.get("avg_duration_ms", 0)),
            last_used=props.get("last_used", ""),
            tags=props.get("tags", []),
        )
